//! StrategyMap - Execution strategy generated from blueprint and available agents.

use serde::{Deserialize, Serialize};

/// Helper function for serde to determine if a bool value is false.
fn is_false(value: &bool) -> bool {
    !*value
}

/// A concrete execution strategy generated by the orchestrator.
///
/// The StrategyMap is created ad-hoc at runtime by analyzing:
/// - The BlueprintWorkflow (what needs to be done)
/// - Available agents (what capabilities exist)
/// - The specific task (the actual user request)
///
/// This allows the orchestrator to adapt to different agent compositions
/// without requiring pre-defined workflows.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StrategyMap {
    /// The overall goal this strategy aims to achieve.
    pub goal: String,

    /// Ordered sequence of steps to execute.
    pub steps: Vec<StrategyStep>,
}

/// A single step in the execution strategy.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct StrategyStep {
    /// Unique identifier for this step (for logging and debugging).
    pub step_id: String,

    /// Natural language description of what this step accomplishes.
    pub description: String,

    /// Name of the agent assigned to execute this step.
    pub assigned_agent: String,

    /// Template for the intent to pass to the agent.
    ///
    /// This template can contain placeholders like `{previous_output}`
    /// that will be filled in by the orchestrator at runtime.
    pub intent_template: String,

    /// Description of what output is expected from this step.
    pub expected_output: String,

    /// Whether this step requires validation before proceeding to the next step.
    /// Defaults to false if not specified.
    #[serde(default, skip_serializing_if = "is_false")]
    pub requires_validation: bool,

    /// Optional custom key for accessing this step's output in context.
    ///
    /// When specified, the output will be accessible as:
    /// - `step_{step_id}_output` (automatic default key)
    /// - `{output_key}` (custom alias for easier reference)
    ///
    /// This allows subsequent steps to reference outputs with meaningful names
    /// instead of auto-generated step IDs.
    ///
    /// Example:
    /// ```json
    /// {
    ///   "step_id": "step_1",
    ///   "output_key": "world_concept",
    ///   "assigned_agent": "WorldConceptAgent"
    /// }
    /// ```
    /// Next step can reference: `{{ world_concept.theme }}`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output_key: Option<String>,
}

impl StrategyMap {
    /// Creates a new empty StrategyMap with a goal.
    pub fn new(goal: String) -> Self {
        Self {
            goal,
            steps: Vec::new(),
        }
    }

    /// Adds a step to this strategy.
    pub fn add_step(&mut self, step: StrategyStep) {
        self.steps.push(step);
    }

    /// Returns the number of steps in this strategy.
    pub fn len(&self) -> usize {
        self.steps.len()
    }

    /// Checks if this strategy has no steps.
    pub fn is_empty(&self) -> bool {
        self.steps.is_empty()
    }

    /// Returns a step by index.
    pub fn get_step(&self, index: usize) -> Option<&StrategyStep> {
        self.steps.get(index)
    }

    /// Returns a mutable reference to a step by index.
    pub fn get_step_mut(&mut self, index: usize) -> Option<&mut StrategyStep> {
        self.steps.get_mut(index)
    }
}

impl StrategyStep {
    /// Creates a new StrategyStep.
    pub fn new(
        step_id: String,
        description: String,
        assigned_agent: String,
        intent_template: String,
        expected_output: String,
    ) -> Self {
        Self {
            step_id,
            description,
            assigned_agent,
            intent_template,
            expected_output,
            requires_validation: false,
            output_key: None,
        }
    }
}

/// The type of redesign strategy to apply when a step fails.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum RedesignStrategy {
    /// Simply retry the same step (for transient errors).
    Retry,

    /// Redesign from the failed step onwards (tactical).
    /// The actual redesigned steps will be generated and applied separately.
    TacticalRedesign,

    /// Regenerate the entire strategy from scratch.
    FullRegenerate,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_strategy_map_creation() {
        let mut strategy = StrategyMap::new("Complete the task".to_string());
        assert_eq!(strategy.goal, "Complete the task");
        assert!(strategy.is_empty());

        let step = StrategyStep::new(
            "step_1".to_string(),
            "Do something".to_string(),
            "AgentA".to_string(),
            "Do {task}".to_string(),
            "Result".to_string(),
        );

        strategy.add_step(step);
        assert_eq!(strategy.len(), 1);
        assert!(!strategy.is_empty());
    }

    #[test]
    fn test_strategy_step_access() {
        let mut strategy = StrategyMap::new("Goal".to_string());

        let step = StrategyStep::new(
            "s1".to_string(),
            "Description".to_string(),
            "Agent".to_string(),
            "Intent".to_string(),
            "Output".to_string(),
        );

        strategy.add_step(step);

        assert!(strategy.get_step(0).is_some());
        assert!(strategy.get_step(1).is_none());

        if let Some(step_mut) = strategy.get_step_mut(0) {
            step_mut.description = "Modified".to_string();
        }

        assert_eq!(strategy.get_step(0).unwrap().description, "Modified");
    }

    #[test]
    fn test_strategy_step_with_output_key() {
        let mut step = StrategyStep::new(
            "step_1".to_string(),
            "Create world concept".to_string(),
            "WorldConceptAgent".to_string(),
            "Create a concept for {{ user_request }}".to_string(),
            "World concept data".to_string(),
        );

        // Initially None
        assert!(step.output_key.is_none());

        // Set output_key
        step.output_key = Some("world_concept".to_string());
        assert_eq!(step.output_key, Some("world_concept".to_string()));

        // Verify serialization includes output_key
        let json = serde_json::to_string(&step).unwrap();
        assert!(json.contains("world_concept"));
    }

    #[test]
    fn test_strategy_step_output_key_serialization() {
        // Test that output_key is properly serialized and deserialized
        let mut step = StrategyStep::new(
            "step_1".to_string(),
            "Test step".to_string(),
            "TestAgent".to_string(),
            "Do something".to_string(),
            "Result".to_string(),
        );
        step.output_key = Some("test_output".to_string());

        let json = serde_json::to_string(&step).unwrap();
        let deserialized: StrategyStep = serde_json::from_str(&json).unwrap();

        assert_eq!(deserialized.output_key, Some("test_output".to_string()));
        assert_eq!(deserialized.step_id, "step_1");
    }

    #[test]
    fn test_strategy_step_without_output_key_serialization() {
        // Test that output_key is omitted from JSON when None (skip_serializing_if)
        let step = StrategyStep::new(
            "step_1".to_string(),
            "Test step".to_string(),
            "TestAgent".to_string(),
            "Do something".to_string(),
            "Result".to_string(),
        );

        let json = serde_json::to_string(&step).unwrap();
        // output_key should not appear in JSON when None
        assert!(!json.contains("output_key"));
    }
}
