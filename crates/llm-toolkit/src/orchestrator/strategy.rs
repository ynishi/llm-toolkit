//! StrategyMap - Execution strategy generated from blueprint and available agents.

use serde::{Deserialize, Serialize};

/// A concrete execution strategy generated by the orchestrator.
///
/// The StrategyMap is created ad-hoc at runtime by analyzing:
/// - The BlueprintWorkflow (what needs to be done)
/// - Available agents (what capabilities exist)
/// - The specific task (the actual user request)
///
/// This allows the orchestrator to adapt to different agent compositions
/// without requiring pre-defined workflows.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StrategyMap {
    /// The overall goal this strategy aims to achieve.
    pub goal: String,

    /// Ordered sequence of steps to execute.
    pub steps: Vec<StrategyStep>,
}

/// A single step in the execution strategy.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct StrategyStep {
    /// Unique identifier for this step (for logging and debugging).
    pub step_id: String,

    /// Natural language description of what this step accomplishes.
    pub description: String,

    /// Name of the agent assigned to execute this step.
    pub assigned_agent: String,

    /// Template for the intent to pass to the agent.
    ///
    /// This template can contain placeholders like `{previous_output}`
    /// that will be filled in by the orchestrator at runtime.
    pub intent_template: String,

    /// Description of what output is expected from this step.
    pub expected_output: String,
}

impl StrategyMap {
    /// Creates a new empty StrategyMap with a goal.
    pub fn new(goal: String) -> Self {
        Self {
            goal,
            steps: Vec::new(),
        }
    }

    /// Adds a step to this strategy.
    pub fn add_step(&mut self, step: StrategyStep) {
        self.steps.push(step);
    }

    /// Returns the number of steps in this strategy.
    pub fn len(&self) -> usize {
        self.steps.len()
    }

    /// Checks if this strategy has no steps.
    pub fn is_empty(&self) -> bool {
        self.steps.is_empty()
    }

    /// Returns a step by index.
    pub fn get_step(&self, index: usize) -> Option<&StrategyStep> {
        self.steps.get(index)
    }

    /// Returns a mutable reference to a step by index.
    pub fn get_step_mut(&mut self, index: usize) -> Option<&mut StrategyStep> {
        self.steps.get_mut(index)
    }
}

impl StrategyStep {
    /// Creates a new StrategyStep.
    pub fn new(
        step_id: String,
        description: String,
        assigned_agent: String,
        intent_template: String,
        expected_output: String,
    ) -> Self {
        Self {
            step_id,
            description,
            assigned_agent,
            intent_template,
            expected_output,
        }
    }
}

/// The type of redesign strategy to apply when a step fails.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum RedesignStrategy {
    /// Simply retry the same step (for transient errors).
    Retry,

    /// Redesign from the failed step onwards (tactical).
    TacticalRedesign(Vec<StrategyStep>),

    /// Regenerate the entire strategy from scratch.
    FullRegenerate,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_strategy_map_creation() {
        let mut strategy = StrategyMap::new("Complete the task".to_string());
        assert_eq!(strategy.goal, "Complete the task");
        assert!(strategy.is_empty());

        let step = StrategyStep::new(
            "step_1".to_string(),
            "Do something".to_string(),
            "AgentA".to_string(),
            "Do {task}".to_string(),
            "Result".to_string(),
        );

        strategy.add_step(step);
        assert_eq!(strategy.len(), 1);
        assert!(!strategy.is_empty());
    }

    #[test]
    fn test_strategy_step_access() {
        let mut strategy = StrategyMap::new("Goal".to_string());

        let step = StrategyStep::new(
            "s1".to_string(),
            "Description".to_string(),
            "Agent".to_string(),
            "Intent".to_string(),
            "Output".to_string(),
        );

        strategy.add_step(step);

        assert!(strategy.get_step(0).is_some());
        assert!(strategy.get_step(1).is_none());

        if let Some(step_mut) = strategy.get_step_mut(0) {
            step_mut.description = "Modified".to_string();
        }

        assert_eq!(strategy.get_step(0).unwrap().description, "Modified");
    }
}
