use super::dialogue::ExecutionModel;
use super::{Agent, AgentError, Payload, PayloadContent, RelatedParticipant, participant_relation};
use crate::ToPrompt;
use crate::agent::payload_message::format_messages_with_relation;
use async_trait::async_trait;
use serde::{Deserialize, Serialize};

/// Persona definition for runtime-generated personas.
///
/// Use this for personas generated by LLMs or loaded from JSON.
/// All fields are owned `String` to support dynamic allocation.
#[derive(ToPrompt, Serialize, Deserialize, Clone, Debug)]
#[prompt(template = "
# Persona Profile
**Name**: {{ name }}
**Role**: {{ role }}

## Background
{{ background }}

## Communication Style
{{ communication_style }}
")]
pub struct Persona {
    pub name: String,
    pub role: String,
    pub background: String,
    pub communication_style: String,
}

/// A team of personas for multi-agent dialogue scenarios.
///
/// PersonaTeam can be generated from a BluePrint description or loaded from JSON.
/// It provides a serializable representation of team composition that can be
/// reused across different tasks.
///
/// # Example
///
/// ```rust,ignore
/// use llm_toolkit::agent::persona::PersonaTeam;
///
/// // Load from JSON
/// let team = PersonaTeam::load("teams/dev_team.json")?;
///
/// // Save to JSON
/// team.save("teams/dev_team_backup.json")?;
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PersonaTeam {
    /// Name of this team (e.g., "HR SaaS Development Team")
    pub team_name: String,

    /// Context/scenario description
    pub context: String,

    /// List of personas in this team
    pub personas: Vec<Persona>,

    /// Optional execution strategy
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution_strategy: Option<ExecutionModel>,
}

/// Request for generating a PersonaTeam from a BluePrint description.
///
/// This struct uses the ToPrompt derive macro to generate a structured prompt
/// for LLM-based persona team generation.
#[derive(Serialize, ToPrompt)]
#[prompt(template = r##"
# Persona Team Generation Task

You are an expert in team composition and organizational dynamics. Your task is to generate a well-balanced team of personas for a specific scenario.

## Scenario Context
{{ context }}

{% if role_descriptions %}
## Required Roles
{{ role_descriptions }}
{% endif %}

{% if team_graph %}
### Team Structure
```mermaid
{{ team_graph }}
```
{% endif %}

---

## Your Task

Generate a PersonaTeam as a JSON object with the following structure:

```json
{
  "team_name": "A descriptive name for this team (e.g., 'HR SaaS Development Team')",
  "context": "Brief description of the scenario/context",
  "execution_strategy": "sequential" or "broadcast" (choose based on the scenario),
  "personas": [
    {
      "name": "A realistic name for this person",
      "role": "Job title/function (e.g., 'Product Owner', 'UX Designer')",
      "background": "2-3 sentences describing their relevant experience, expertise, and perspective. Be specific to make them feel real.",
      "communication_style": "1-2 sentences describing how they communicate, make decisions, and collaborate with others."
    }
  ]
}
```

**Guidelines:**

1. **Team Composition**: Analyze the scenario and create personas that cover all necessary perspectives and expertise areas
2. **Balanced Team**: Ensure diversity in perspectives, experience levels, and communication styles
3. **Realistic Personas**: Give each persona:
   - A realistic name (vary cultural backgrounds naturally)
   - Specific expertise and experience (not generic)
   - Distinct communication style (some data-driven, some user-focused, etc.)
   - Believable background (mention years of experience, past roles, specializations)

4. **Execution Strategy Selection**:
   - Use "broadcast" for brainstorming, reviews, or when all voices should be heard simultaneously
   - Use "sequential" for process-driven workflows (e.g., requirements → design → implementation → QA)

5. **Team Size**: Generally 3-6 personas is ideal. Too few lacks perspective; too many becomes unwieldy.

6. **Role Coverage**: For typical product development scenarios, consider including:
   - Decision maker (Product Owner, Tech Lead)
   - User advocate (UX Designer, Customer Success)
   - Technical experts (Engineers, Architects)
   - Quality/Risk (QA, Security, DevOps if relevant)

**Important:** Return ONLY the JSON object, no additional explanation or commentary.
"##)]
pub struct PersonaTeamGenerationRequest {
    pub context: String,
    #[serde(skip_serializing_if = "String::is_empty")]
    pub role_descriptions: String,
    #[serde(skip_serializing_if = "String::is_empty")]
    pub team_graph: String,
}

impl PersonaTeamGenerationRequest {
    /// Creates a new generation request.
    pub fn new(context: String) -> Self {
        Self {
            context,
            role_descriptions: String::new(),
            team_graph: String::new(),
        }
    }

    /// Sets the role descriptions.
    pub fn with_role_descriptions(mut self, descriptions: String) -> Self {
        self.role_descriptions = descriptions;
        self
    }

    /// Sets the team graph (Mermaid diagram).
    pub fn with_team_graph(mut self, graph: String) -> Self {
        self.team_graph = graph;
        self
    }
}

impl PersonaTeam {
    /// Creates a new PersonaTeam.
    pub fn new(team_name: String, context: String) -> Self {
        Self {
            team_name,
            context,
            personas: Vec::new(),
            execution_strategy: None,
        }
    }

    /// Adds a persona to this team.
    pub fn add_persona(&mut self, persona: Persona) -> &mut Self {
        self.personas.push(persona);
        self
    }

    /// Sets the execution strategy.
    pub fn with_execution_strategy(mut self, strategy: ExecutionModel) -> Self {
        self.execution_strategy = Some(strategy);
        self
    }

    /// Loads a PersonaTeam from a JSON file.
    ///
    /// # Errors
    ///
    /// Returns an error if the file cannot be read or parsed.
    pub fn load(path: impl AsRef<std::path::Path>) -> Result<Self, std::io::Error> {
        let content = std::fs::read_to_string(path)?;
        serde_json::from_str(&content)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))
    }

    /// Saves this PersonaTeam to a JSON file.
    ///
    /// # Errors
    ///
    /// Returns an error if the file cannot be written.
    pub fn save(&self, path: impl AsRef<std::path::Path>) -> Result<(), std::io::Error> {
        let content = serde_json::to_string_pretty(self)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))?;
        std::fs::write(path, content)
    }
}

/// Formats participants information with relation interpretation.
///
/// The current agent (self) is marked as "YOU" or "ME", while other participants
/// are listed with their speaker information.
///
/// # Arguments
///
/// * `participants` - List of all participants in the dialogue
/// * `self_name` - Name of the current agent (persona)
fn relate_participants<'a>(
    participants: impl IntoIterator<Item = &'a super::dialogue::ParticipantInfo>,
    self_name: &str,
) -> Vec<RelatedParticipant> {
    participants
        .into_iter()
        .cloned()
        .map(|participant| {
            let relation = participant_relation(&participant, self_name);
            RelatedParticipant::new(participant, relation)
        })
        .collect()
}

fn format_participants_with_relation(
    participants: &[super::dialogue::ParticipantInfo],
    self_name: &str,
) -> String {
    relate_participants(participants.iter(), self_name)
        .into_iter()
        .map(|participant| participant.format_line())
        .collect::<Vec<_>>()
        .join("\n")
}

/// Structured prompt for PersonaAgent that combines persona information,
/// participants context, and current content (text or messages).
///
/// This structure allows PersonaAgent to build prompts in a type-safe way
/// and defer the actual text formatting until needed.
#[derive(ToPrompt, Serialize)]
#[prompt(template = r#"YOU ARE A PERSONA-DRIVEN AI AGENT.
YOU ARE {{ persona.name }} WHO SERVES AS {{ persona.role }}.

{{persona}}{% if participants %}

# Participants
{{participants}}
{% endif %}{% if context %}

# Conversation Context (History)
{{context}}
{% endif %}{% if current_content %}

# Current Messages
{{current_content}}
{% endif %}"#)]
struct PersonaAgentPrompt {
    persona: Persona,
    #[serde(skip_serializing_if = "String::is_empty")]
    participants: String,
    #[serde(skip_serializing_if = "String::is_empty")]
    context: String,
    #[serde(skip_serializing_if = "String::is_empty")]
    current_content: String,
}

pub struct PersonaAgent<T: Agent> {
    inner_agent: T,
    persona: Persona,
}

impl<T: Agent> PersonaAgent<T> {
    pub fn new(inner_agent: T, persona: Persona) -> Self {
        Self {
            inner_agent,
            persona,
        }
    }
}

#[async_trait]
impl<T> Agent for PersonaAgent<T>
where
    T: Agent + Send + Sync,
    T::Output: Send,
{
    type Output = T::Output;

    fn expertise(&self) -> &str {
        &self.persona.role
    }

    #[crate::tracing::instrument(
        name = "persona_agent.execute",
        skip(self, intent),
        fields(
            agent.name = %self.persona.name,
            agent.role = %self.persona.role,
            has_participants = intent.participants().is_some(),
            message_count = intent.to_messages().len(),
        )
    )]
    async fn execute(&self, intent: Payload) -> Result<Self::Output, AgentError> {
        // 1. Extract and format participants with relation interpretation (YOU/ME marking)
        let participants_text = intent
            .participants()
            .map(|participants| format_participants_with_relation(participants, &self.persona.name))
            .unwrap_or_default();

        // 2. Get context text from HistoryAwareAgent (if provided)
        let context_text = intent.to_text();

        // 3. Extract and format current messages (the diff) with YOU/ME marking
        let messages = intent.to_messages();
        let total_content_count = intent.total_content_count();
        let current_messages_text =
            format_messages_with_relation(&messages, &self.persona.name, total_content_count);

        // 5. Build structured prompt
        let prompt_struct = PersonaAgentPrompt {
            persona: self.persona.clone(),
            participants: participants_text,
            context: context_text,
            current_content: current_messages_text,
        };

        // 6. Convert to text
        let prompt_text = prompt_struct.to_prompt();

        // Debug log the generated prompt
        crate::tracing::debug!(
            target: "llm_toolkit::agent::persona",
            persona_name = %self.persona.name,
            prompt_length = prompt_text.len(),
            "Generated persona prompt"
        );
        crate::tracing::trace!(
            target: "llm_toolkit::agent::persona",
            "\n========== PERSONA PROMPT ==========\n{}\n====================================",
            prompt_text
        );

        // 7. Create payload with Text + Messages (preserved)
        let mut final_payload = Payload::text(prompt_text);

        // Preserve messages structure
        for message in messages {
            final_payload = final_payload.with_message(message.speaker, message.content);
        }

        // Preserve attachments
        for content in intent.contents() {
            if let PayloadContent::Attachment(attachment) = content {
                final_payload = final_payload.with_attachment(attachment.clone());
            }
        }

        self.inner_agent.execute(final_payload).await
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::agent::{Agent, AgentError, Payload, PayloadMessage};
    use crate::attachment::Attachment;
    use async_trait::async_trait;
    use serde::de::DeserializeOwned;
    use std::sync::Arc;
    use tokio::sync::Mutex;

    #[derive(Clone)]
    struct RecordingAgent<T: Clone + Serialize + DeserializeOwned + Send + Sync + 'static> {
        calls: Arc<Mutex<Vec<Payload>>>,
        response: T,
    }

    impl<T: Clone + Serialize + DeserializeOwned + Send + Sync + 'static> RecordingAgent<T> {
        fn new(response: T) -> Self {
            Self {
                calls: Arc::new(Mutex::new(Vec::new())),
                response,
            }
        }

        async fn last_call(&self) -> Option<Payload> {
            self.calls.lock().await.last().cloned()
        }
    }

    #[async_trait]
    impl<T> Agent for RecordingAgent<T>
    where
        T: Clone + Serialize + DeserializeOwned + Send + Sync + 'static,
    {
        type Output = T;

        fn expertise(&self) -> &str {
            "Test agent"
        }

        async fn execute(&self, intent: Payload) -> Result<Self::Output, AgentError> {
            self.calls.lock().await.push(intent);
            Ok(self.response.clone())
        }
    }

    #[tokio::test]
    async fn persona_agent_preserves_attachments() {
        let persona = Persona {
            name: "Tester".to_string(),
            role: "Attachment Checker".to_string(),
            background: "Validates payload handling.".to_string(),
            communication_style: "Direct and concise.".to_string(),
        };

        let base_agent = RecordingAgent::new(String::from("ok"));
        let persona_agent = PersonaAgent::new(base_agent.clone(), persona);

        let attachment = Attachment::in_memory(vec![1, 2, 3]);
        let payload = Payload::text("Please inspect the data").with_attachment(attachment.clone());

        let _ = persona_agent.execute(payload).await.unwrap();

        let recorded_payload = base_agent.last_call().await.expect("call recorded");
        assert!(
            recorded_payload.has_attachments(),
            "attachments should be preserved"
        );
        let attachments = recorded_payload.attachments();
        assert_eq!(attachments.len(), 1);
        assert_eq!(attachments[0], &attachment);
    }

    #[tokio::test]
    async fn persona_agent_works() {
        let persona = Persona {
            name: "TestBot".to_string(),
            role: "Test Assistant".to_string(),
            background: "A helpful test bot for unit testing".to_string(),
            communication_style: "Direct and clear".to_string(),
        };

        let base_agent = RecordingAgent::new(String::from("response"));
        let persona_agent = PersonaAgent::new(base_agent.clone(), persona);

        let result = persona_agent.execute(Payload::text("Hello")).await.unwrap();
        assert_eq!(result, "response");

        let call = base_agent.last_call().await.expect("call recorded");
        let call_text = call.to_text();
        assert!(call_text.contains("Persona Profile"));
        assert!(call_text.contains("TestBot"));
        assert!(call_text.contains("Test Assistant"));
    }

    #[test]
    fn persona_to_prompt_template_expansion() {
        use crate::ToPrompt;

        let persona = Persona {
            name: "Alice".to_string(),
            role: "Engineer".to_string(),
            background: "Senior software engineer with 10 years of experience".to_string(),
            communication_style: "Direct and clear".to_string(),
        };

        let prompt = persona.to_prompt();

        // Verify template variables are expanded (not left as {{ name }})
        assert!(
            !prompt.contains("{{ name }}"),
            "Template variables should be expanded, not left as placeholders"
        );
        assert!(
            !prompt.contains("{{ role }}"),
            "Template variables should be expanded, not left as placeholders"
        );
        assert!(
            !prompt.contains("{{ background }}"),
            "Template variables should be expanded, not left as placeholders"
        );
        assert!(
            !prompt.contains("{{ communication_style }}"),
            "Template variables should be expanded, not left as placeholders"
        );

        // Verify actual values are present
        assert!(prompt.contains("Alice"), "Name should be in prompt");
        assert!(prompt.contains("Engineer"), "Role should be in prompt");
        assert!(
            prompt.contains("Senior software engineer"),
            "Background should be in prompt"
        );
        assert!(
            prompt.contains("Direct and clear"),
            "Communication style should be in prompt"
        );

        // Verify structure
        assert!(prompt.contains("# Persona Profile"), "Should have header");
        assert!(prompt.contains("**Name**:"), "Should have Name label");
        assert!(prompt.contains("**Role**:"), "Should have Role label");
        assert!(
            prompt.contains("## Background"),
            "Should have Background section"
        );
        assert!(
            prompt.contains("## Communication Style"),
            "Should have Communication Style section"
        );

        println!("Generated prompt:\n{}", prompt);
    }

    #[test]
    fn persona_agent_prompt_nested_template_expansion() {
        use crate::ToPrompt;

        let persona = Persona {
            name: "Alice".to_string(),
            role: "Engineer".to_string(),
            background: "Senior software engineer".to_string(),
            communication_style: "Direct and clear".to_string(),
        };

        let prompt_struct = PersonaAgentPrompt {
            persona: persona.clone(),
            participants: "- Bob (Developer)\n- Charlie (Designer)".to_string(),
            context: String::new(),
            current_content: "Please review the code".to_string(),
        };

        let prompt = prompt_struct.to_prompt();
        println!(
            "=== Generated PersonaAgentPrompt ===\n{}\n=== End ===",
            prompt
        );

        // The issue: when we use {{persona}} in template, it gets JSON serialized
        // instead of using Persona's own ToPrompt template

        // Check if it's JSON serialized (the problem we're trying to fix)
        let is_json_serialized = prompt.contains(r#""name""#) || prompt.contains(r#""role""#);

        if is_json_serialized {
            println!(
                "ISSUE CONFIRMED: Persona is being JSON serialized instead of using its ToPrompt template"
            );
            println!("Expected: Persona's formatted template with markdown");
            println!("Actual: JSON representation of Persona struct");
        }

        // What we want: Persona's template should be expanded
        assert!(
            prompt.contains("# Persona Profile"),
            "Should contain Persona's template header (not JSON)"
        );
        assert!(
            prompt.contains("**Name**: Alice"),
            "Should use Persona's template format (not JSON)"
        );
        assert!(
            !is_json_serialized,
            "Persona should use its ToPrompt template, not JSON serialization"
        );
    }

    #[test]
    fn persona_team_serialization() {
        let mut team = PersonaTeam::new("Test Team".to_string(), "Testing scenario".to_string());

        team.add_persona(Persona {
            name: "Alice".to_string(),
            role: "Developer".to_string(),
            background: "Senior engineer".to_string(),
            communication_style: "Technical".to_string(),
        });

        team.add_persona(Persona {
            name: "Bob".to_string(),
            role: "Designer".to_string(),
            background: "UX specialist".to_string(),
            communication_style: "User-focused".to_string(),
        });

        // Serialize
        let json = serde_json::to_string_pretty(&team).unwrap();
        assert!(json.contains("Test Team"));
        assert!(json.contains("Alice"));
        assert!(json.contains("Bob"));

        // Deserialize
        let deserialized: PersonaTeam = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.team_name, "Test Team");
        assert_eq!(deserialized.personas.len(), 2);
        assert_eq!(deserialized.personas[0].name, "Alice");
        assert_eq!(deserialized.personas[1].name, "Bob");
    }

    #[test]
    fn persona_team_load_save() {
        use tempfile::NamedTempFile;

        let mut team = PersonaTeam::new("Dev Team".to_string(), "Software development".to_string());
        team.add_persona(Persona {
            name: "Charlie".to_string(),
            role: "Tech Lead".to_string(),
            background: "10 years experience".to_string(),
            communication_style: "Strategic".to_string(),
        });

        // Save to temp file
        let temp_file = NamedTempFile::new().unwrap();
        let path = temp_file.path();
        team.save(path).unwrap();

        // Load back
        let loaded = PersonaTeam::load(path).unwrap();
        assert_eq!(loaded.team_name, "Dev Team");
        assert_eq!(loaded.personas.len(), 1);
        assert_eq!(loaded.personas[0].name, "Charlie");
    }

    #[test]
    fn persona_team_generation_request_prompt() {
        use crate::ToPrompt;

        let request = PersonaTeamGenerationRequest::new(
            "Product development meeting for HR SaaS".to_string(),
        )
        .with_role_descriptions("PO, Designer, Engineer".to_string());

        let prompt = request.to_prompt();
        assert!(prompt.contains("Persona Team Generation Task"));
        assert!(prompt.contains("Product development meeting"));
        assert!(prompt.contains("PO, Designer, Engineer"));
    }

    #[tokio::test]
    async fn persona_agent_formats_participants_with_self_as_you() {
        use crate::agent::dialogue::ParticipantInfo;

        let persona = Persona {
            name: "Alice".to_string(),
            role: "PM".to_string(),
            background: "Product manager".to_string(),
            communication_style: "Strategic".to_string(),
        };

        let participants = vec![
            ParticipantInfo::new(
                "Alice".to_string(),
                "PM".to_string(),
                "Product manager".to_string(),
            ),
            ParticipantInfo::new(
                "Bob".to_string(),
                "Engineer".to_string(),
                "Backend developer".to_string(),
            ),
        ];

        let base_agent = RecordingAgent::new("response".to_string());
        let persona_agent = PersonaAgent::new(base_agent.clone(), persona);

        let payload = Payload::text("Task").with_participants(participants);

        let _ = persona_agent.execute(payload).await.unwrap();

        let call = base_agent.last_call().await.unwrap();
        let call_text = call.to_text();

        // Alice should be marked as "YOU"
        assert!(call_text.contains("Alice (YOU)"));
        // Bob should not be marked as "YOU"
        assert!(call_text.contains("Bob"));
        assert!(!call_text.contains("Bob (YOU)"));
    }

    #[tokio::test]
    async fn persona_agent_formats_messages() {
        let persona = Persona {
            name: "Agent".to_string(),
            role: "Assistant".to_string(),
            background: "Helper".to_string(),
            communication_style: "Friendly".to_string(),
        };

        let base_agent = RecordingAgent::new("response".to_string());
        let persona_agent = PersonaAgent::new(base_agent.clone(), persona);

        let payload = Payload::from_messages(vec![
            PayloadMessage::system("System instruction"),
            PayloadMessage::user("Alice", "PM", "User message"),
        ]);

        let _ = persona_agent.execute(payload).await.unwrap();

        let call = base_agent.last_call().await.unwrap();
        let call_text = call.to_text();

        // Messages should be formatted with speaker names
        assert!(call_text.contains("[System]: System instruction"));
        assert!(call_text.contains("[Alice]: User message"));
    }

    #[tokio::test]
    async fn persona_agent_preserves_messages_structure() {
        use crate::agent::dialogue::Speaker;

        let persona = Persona {
            name: "Agent".to_string(),
            role: "Assistant".to_string(),
            background: "Helper".to_string(),
            communication_style: "Friendly".to_string(),
        };

        let base_agent = RecordingAgent::new("response".to_string());
        let persona_agent = PersonaAgent::new(base_agent.clone(), persona);

        let original_messages = vec![
            PayloadMessage::system("System msg"),
            PayloadMessage::user("Alice", "PM", "User msg"),
        ];

        let payload = Payload::from_messages(original_messages.clone());

        let _ = persona_agent.execute(payload).await.unwrap();

        let call = base_agent.last_call().await.unwrap();
        let received_messages = call.to_messages();

        // Messages should be preserved in the payload
        assert_eq!(received_messages.len(), original_messages.len());
        assert_eq!(received_messages[0].speaker, Speaker::System);
        assert_eq!(received_messages[0].content, "System msg");
        assert_eq!(received_messages[1].speaker, Speaker::user("Alice", "PM"));
        assert_eq!(received_messages[1].content, "User msg");
    }

    #[tokio::test]
    async fn persona_agent_full_integration() {
        use crate::agent::dialogue::{ParticipantInfo, Speaker};

        let persona = Persona {
            name: "Alice".to_string(),
            role: "PM".to_string(),
            background: "Product manager with 5 years experience".to_string(),
            communication_style: "Strategic and data-driven".to_string(),
        };

        let participants = vec![
            ParticipantInfo::new(
                "Alice".to_string(),
                "PM".to_string(),
                "Product manager".to_string(),
            ),
            ParticipantInfo::new(
                "Bob".to_string(),
                "Engineer".to_string(),
                "Backend developer".to_string(),
            ),
        ];

        let messages = vec![
            PayloadMessage::system("Discuss feature priorities"),
            PayloadMessage::user("Bob", "Engineer", "I suggest we focus on performance"),
        ];

        let base_agent = RecordingAgent::new("Good idea".to_string());
        let persona_agent = PersonaAgent::new(base_agent.clone(), persona);

        let payload = Payload::from_messages(messages.clone()).with_participants(participants);

        let result = persona_agent.execute(payload).await.unwrap();
        assert_eq!(result, "Good idea");

        let call = base_agent.last_call().await.unwrap();
        let call_text = call.to_text();

        // Debug: print actual output
        println!("=== Actual call_text ===\n{}\n=== End ===", call_text);

        // Verify all components are present
        assert!(call_text.contains("# Persona Profile"));
        assert!(call_text.contains("**Name**: Alice"));
        assert!(call_text.contains("# Participants"));
        assert!(call_text.contains("**Alice (YOU)**"));
        assert!(call_text.contains("**Bob (ALLY)**"));
        assert!(call_text.contains("# Current Messages"));
        assert!(call_text.contains("[System]: Discuss feature priorities"));
        assert!(call_text.contains("[Bob]: I suggest we focus on performance"));

        // Verify messages are preserved (Text is excluded, only Message variants)
        let received_messages = call.to_messages();
        assert_eq!(received_messages.len(), 2);
        assert_eq!(received_messages[0].speaker, Speaker::System);
        assert_eq!(received_messages[0].content, "Discuss feature priorities");
        assert_eq!(
            received_messages[1].speaker,
            Speaker::user("Bob", "Engineer")
        );
        assert_eq!(
            received_messages[1].content,
            "I suggest we focus on performance"
        );
    }
}
