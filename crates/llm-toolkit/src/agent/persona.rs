use super::dialogue::ExecutionModel;
use super::{Agent, AgentError, Payload, PayloadContent};
use crate::ToPrompt;
use async_trait::async_trait;
use serde::{Deserialize, Serialize};

/// Persona definition for runtime-generated personas.
///
/// Use this for personas generated by LLMs or loaded from JSON.
/// All fields are owned `String` to support dynamic allocation.
#[derive(ToPrompt, Serialize, Deserialize, Clone, Debug)]
#[prompt(template = "
# Persona Profile
**Name**: {{ name }}
**Role**: {{ role }}

## Background
{{ background }}

## Communication Style
{{ communication_style }}
")]
pub struct Persona {
    pub name: String,
    pub role: String,
    pub background: String,
    pub communication_style: String,
}

/// A team of personas for multi-agent dialogue scenarios.
///
/// PersonaTeam can be generated from a BluePrint description or loaded from JSON.
/// It provides a serializable representation of team composition that can be
/// reused across different tasks.
///
/// # Example
///
/// ```rust,ignore
/// use llm_toolkit::agent::persona::PersonaTeam;
///
/// // Load from JSON
/// let team = PersonaTeam::load("teams/dev_team.json")?;
///
/// // Save to JSON
/// team.save("teams/dev_team_backup.json")?;
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PersonaTeam {
    /// Name of this team (e.g., "HR SaaS Development Team")
    pub team_name: String,

    /// Context/scenario description
    pub context: String,

    /// List of personas in this team
    pub personas: Vec<Persona>,

    /// Optional execution strategy
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution_strategy: Option<ExecutionModel>,
}

/// Request for generating a PersonaTeam from a BluePrint description.
///
/// This struct uses the ToPrompt derive macro to generate a structured prompt
/// for LLM-based persona team generation.
#[derive(Serialize, ToPrompt)]
#[prompt(template = r##"
# Persona Team Generation Task

You are an expert in team composition and organizational dynamics. Your task is to generate a well-balanced team of personas for a specific scenario.

## Scenario Context
{{ context }}

{% if role_descriptions %}
## Required Roles
{{ role_descriptions }}
{% endif %}

{% if team_graph %}
### Team Structure
```mermaid
{{ team_graph }}
```
{% endif %}

---

## Your Task

Generate a PersonaTeam as a JSON object with the following structure:

```json
{
  "team_name": "A descriptive name for this team (e.g., 'HR SaaS Development Team')",
  "context": "Brief description of the scenario/context",
  "execution_strategy": "sequential" or "broadcast" (choose based on the scenario),
  "personas": [
    {
      "name": "A realistic name for this person",
      "role": "Job title/function (e.g., 'Product Owner', 'UX Designer')",
      "background": "2-3 sentences describing their relevant experience, expertise, and perspective. Be specific to make them feel real.",
      "communication_style": "1-2 sentences describing how they communicate, make decisions, and collaborate with others."
    }
  ]
}
```

**Guidelines:**

1. **Team Composition**: Analyze the scenario and create personas that cover all necessary perspectives and expertise areas
2. **Balanced Team**: Ensure diversity in perspectives, experience levels, and communication styles
3. **Realistic Personas**: Give each persona:
   - A realistic name (vary cultural backgrounds naturally)
   - Specific expertise and experience (not generic)
   - Distinct communication style (some data-driven, some user-focused, etc.)
   - Believable background (mention years of experience, past roles, specializations)

4. **Execution Strategy Selection**:
   - Use "broadcast" for brainstorming, reviews, or when all voices should be heard simultaneously
   - Use "sequential" for process-driven workflows (e.g., requirements → design → implementation → QA)

5. **Team Size**: Generally 3-6 personas is ideal. Too few lacks perspective; too many becomes unwieldy.

6. **Role Coverage**: For typical product development scenarios, consider including:
   - Decision maker (Product Owner, Tech Lead)
   - User advocate (UX Designer, Customer Success)
   - Technical experts (Engineers, Architects)
   - Quality/Risk (QA, Security, DevOps if relevant)

**Important:** Return ONLY the JSON object, no additional explanation or commentary.
"##)]
pub struct PersonaTeamGenerationRequest {
    pub context: String,
    #[serde(skip_serializing_if = "String::is_empty")]
    pub role_descriptions: String,
    #[serde(skip_serializing_if = "String::is_empty")]
    pub team_graph: String,
}

impl PersonaTeamGenerationRequest {
    /// Creates a new generation request.
    pub fn new(context: String) -> Self {
        Self {
            context,
            role_descriptions: String::new(),
            team_graph: String::new(),
        }
    }

    /// Sets the role descriptions.
    pub fn with_role_descriptions(mut self, descriptions: String) -> Self {
        self.role_descriptions = descriptions;
        self
    }

    /// Sets the team graph (Mermaid diagram).
    pub fn with_team_graph(mut self, graph: String) -> Self {
        self.team_graph = graph;
        self
    }
}

impl PersonaTeam {
    /// Creates a new PersonaTeam.
    pub fn new(team_name: String, context: String) -> Self {
        Self {
            team_name,
            context,
            personas: Vec::new(),
            execution_strategy: None,
        }
    }

    /// Adds a persona to this team.
    pub fn add_persona(&mut self, persona: Persona) -> &mut Self {
        self.personas.push(persona);
        self
    }

    /// Sets the execution strategy.
    pub fn with_execution_strategy(mut self, strategy: ExecutionModel) -> Self {
        self.execution_strategy = Some(strategy);
        self
    }

    /// Loads a PersonaTeam from a JSON file.
    ///
    /// # Errors
    ///
    /// Returns an error if the file cannot be read or parsed.
    pub fn load(path: impl AsRef<std::path::Path>) -> Result<Self, std::io::Error> {
        let content = std::fs::read_to_string(path)?;
        serde_json::from_str(&content)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))
    }

    /// Saves this PersonaTeam to a JSON file.
    ///
    /// # Errors
    ///
    /// Returns an error if the file cannot be written.
    pub fn save(&self, path: impl AsRef<std::path::Path>) -> Result<(), std::io::Error> {
        let content = serde_json::to_string_pretty(self)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))?;
        std::fs::write(path, content)
    }
}

pub struct PersonaAgent<T: Agent> {
    inner_agent: T,
    persona: Persona,
}

impl<T: Agent> PersonaAgent<T> {
    pub fn new(inner_agent: T, persona: Persona) -> Self {
        Self {
            inner_agent,
            persona,
        }
    }
}

#[async_trait]
impl<T> Agent for PersonaAgent<T>
where
    T: Agent + Send + Sync,
    T::Output: Send,
{
    type Output = T::Output;

    fn expertise(&self) -> &str {
        &self.persona.role
    }

    async fn execute(&self, intent: Payload) -> Result<Self::Output, AgentError> {
        let system_prompt = self.persona.to_prompt();
        let user_request = intent.to_text();

        let final_prompt = format!("{}\n\n# Request\n{}", system_prompt, user_request);

        let mut final_payload = Payload::text(final_prompt);

        for content in intent.contents() {
            if let PayloadContent::Attachment(attachment) = content {
                final_payload = final_payload.with_attachment(attachment.clone());
            }
        }

        self.inner_agent.execute(final_payload).await
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::agent::{Agent, AgentError, Payload};
    use crate::attachment::Attachment;
    use async_trait::async_trait;
    use serde::de::DeserializeOwned;
    use std::sync::Arc;
    use tokio::sync::Mutex;

    #[derive(Clone)]
    struct RecordingAgent<T: Clone + Serialize + DeserializeOwned + Send + Sync + 'static> {
        calls: Arc<Mutex<Vec<Payload>>>,
        response: T,
    }

    impl<T: Clone + Serialize + DeserializeOwned + Send + Sync + 'static> RecordingAgent<T> {
        fn new(response: T) -> Self {
            Self {
                calls: Arc::new(Mutex::new(Vec::new())),
                response,
            }
        }

        async fn last_call(&self) -> Option<Payload> {
            self.calls.lock().await.last().cloned()
        }
    }

    #[async_trait]
    impl<T> Agent for RecordingAgent<T>
    where
        T: Clone + Serialize + DeserializeOwned + Send + Sync + 'static,
    {
        type Output = T;

        fn expertise(&self) -> &str {
            "Test agent"
        }

        async fn execute(&self, intent: Payload) -> Result<Self::Output, AgentError> {
            self.calls.lock().await.push(intent);
            Ok(self.response.clone())
        }
    }

    #[tokio::test]
    async fn persona_agent_preserves_attachments() {
        let persona = Persona {
            name: "Tester".to_string(),
            role: "Attachment Checker".to_string(),
            background: "Validates payload handling.".to_string(),
            communication_style: "Direct and concise.".to_string(),
        };

        let base_agent = RecordingAgent::new(String::from("ok"));
        let persona_agent = PersonaAgent::new(base_agent.clone(), persona);

        let attachment = Attachment::in_memory(vec![1, 2, 3]);
        let payload = Payload::text("Please inspect the data").with_attachment(attachment.clone());

        let _ = persona_agent.execute(payload).await.unwrap();

        let recorded_payload = base_agent.last_call().await.expect("call recorded");
        assert!(
            recorded_payload.has_attachments(),
            "attachments should be preserved"
        );
        let attachments = recorded_payload.attachments();
        assert_eq!(attachments.len(), 1);
        assert_eq!(attachments[0], &attachment);
    }

    #[tokio::test]
    async fn persona_agent_works() {
        let persona = Persona {
            name: "TestBot".to_string(),
            role: "Test Assistant".to_string(),
            background: "A helpful test bot for unit testing".to_string(),
            communication_style: "Direct and clear".to_string(),
        };

        let base_agent = RecordingAgent::new(String::from("response"));
        let persona_agent = PersonaAgent::new(base_agent.clone(), persona);

        let result = persona_agent.execute(Payload::text("Hello")).await.unwrap();
        assert_eq!(result, "response");

        let call = base_agent.last_call().await.expect("call recorded");
        let call_text = call.to_text();
        assert!(call_text.contains("Persona Profile"));
        assert!(call_text.contains("TestBot"));
        assert!(call_text.contains("Test Assistant"));
    }

    #[test]
    fn persona_team_serialization() {
        let mut team = PersonaTeam::new("Test Team".to_string(), "Testing scenario".to_string());

        team.add_persona(Persona {
            name: "Alice".to_string(),
            role: "Developer".to_string(),
            background: "Senior engineer".to_string(),
            communication_style: "Technical".to_string(),
        });

        team.add_persona(Persona {
            name: "Bob".to_string(),
            role: "Designer".to_string(),
            background: "UX specialist".to_string(),
            communication_style: "User-focused".to_string(),
        });

        // Serialize
        let json = serde_json::to_string_pretty(&team).unwrap();
        assert!(json.contains("Test Team"));
        assert!(json.contains("Alice"));
        assert!(json.contains("Bob"));

        // Deserialize
        let deserialized: PersonaTeam = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.team_name, "Test Team");
        assert_eq!(deserialized.personas.len(), 2);
        assert_eq!(deserialized.personas[0].name, "Alice");
        assert_eq!(deserialized.personas[1].name, "Bob");
    }

    #[test]
    fn persona_team_load_save() {
        use tempfile::NamedTempFile;

        let mut team = PersonaTeam::new("Dev Team".to_string(), "Software development".to_string());
        team.add_persona(Persona {
            name: "Charlie".to_string(),
            role: "Tech Lead".to_string(),
            background: "10 years experience".to_string(),
            communication_style: "Strategic".to_string(),
        });

        // Save to temp file
        let temp_file = NamedTempFile::new().unwrap();
        let path = temp_file.path();
        team.save(path).unwrap();

        // Load back
        let loaded = PersonaTeam::load(path).unwrap();
        assert_eq!(loaded.team_name, "Dev Team");
        assert_eq!(loaded.personas.len(), 1);
        assert_eq!(loaded.personas[0].name, "Charlie");
    }

    #[test]
    fn persona_team_generation_request_prompt() {
        use crate::ToPrompt;

        let request = PersonaTeamGenerationRequest::new(
            "Product development meeting for HR SaaS".to_string(),
        )
        .with_role_descriptions("PO, Designer, Engineer".to_string());

        let prompt = request.to_prompt();
        assert!(prompt.contains("Persona Team Generation Task"));
        assert!(prompt.contains("Product development meeting"));
        assert!(prompt.contains("PO, Designer, Engineer"));
    }
}
