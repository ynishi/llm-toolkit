use super::dialogue::ExecutionModel;
use super::{Agent, AgentError, Payload, PayloadContent};
use crate::ToPrompt;
use async_trait::async_trait;
use serde::{Deserialize, Serialize};

/// Persona definition for runtime-generated personas.
///
/// Use this for personas generated by LLMs or loaded from JSON.
/// All fields are owned `String` to support dynamic allocation.
#[derive(ToPrompt, Serialize, Deserialize, Clone, Debug)]
#[prompt(template = "
# Persona Profile
**Name**: {{ name }}
**Role**: {{ role }}

## Background
{{ background }}

## Communication Style
{{ communication_style }}
")]
pub struct Persona {
    pub name: String,
    pub role: String,
    pub background: String,
    pub communication_style: String,
}

/// A team of personas for multi-agent dialogue scenarios.
///
/// PersonaTeam can be generated from a BluePrint description or loaded from JSON.
/// It provides a serializable representation of team composition that can be
/// reused across different tasks.
///
/// # Example
///
/// ```rust,ignore
/// use llm_toolkit::agent::persona::PersonaTeam;
///
/// // Load from JSON
/// let team = PersonaTeam::load("teams/dev_team.json")?;
///
/// // Save to JSON
/// team.save("teams/dev_team_backup.json")?;
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PersonaTeam {
    /// Name of this team (e.g., "HR SaaS Development Team")
    pub team_name: String,

    /// Context/scenario description
    pub context: String,

    /// List of personas in this team
    pub personas: Vec<Persona>,

    /// Optional execution strategy
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution_strategy: Option<ExecutionModel>,
}

/// Request for generating a PersonaTeam from a BluePrint description.
///
/// This struct uses the ToPrompt derive macro to generate a structured prompt
/// for LLM-based persona team generation.
#[derive(Serialize, ToPrompt)]
#[prompt(template = r##"
# Persona Team Generation Task

You are an expert in team composition and organizational dynamics. Your task is to generate a well-balanced team of personas for a specific scenario.

## Scenario Context
{{ context }}

{% if role_descriptions %}
## Required Roles
{{ role_descriptions }}
{% endif %}

{% if team_graph %}
### Team Structure
```mermaid
{{ team_graph }}
```
{% endif %}

---

## Your Task

Generate a PersonaTeam as a JSON object with the following structure:

```json
{
  "team_name": "A descriptive name for this team (e.g., 'HR SaaS Development Team')",
  "context": "Brief description of the scenario/context",
  "execution_strategy": "sequential" or "broadcast" (choose based on the scenario),
  "personas": [
    {
      "name": "A realistic name for this person",
      "role": "Job title/function (e.g., 'Product Owner', 'UX Designer')",
      "background": "2-3 sentences describing their relevant experience, expertise, and perspective. Be specific to make them feel real.",
      "communication_style": "1-2 sentences describing how they communicate, make decisions, and collaborate with others."
    }
  ]
}
```

**Guidelines:**

1. **Team Composition**: Analyze the scenario and create personas that cover all necessary perspectives and expertise areas
2. **Balanced Team**: Ensure diversity in perspectives, experience levels, and communication styles
3. **Realistic Personas**: Give each persona:
   - A realistic name (vary cultural backgrounds naturally)
   - Specific expertise and experience (not generic)
   - Distinct communication style (some data-driven, some user-focused, etc.)
   - Believable background (mention years of experience, past roles, specializations)

4. **Execution Strategy Selection**:
   - Use "broadcast" for brainstorming, reviews, or when all voices should be heard simultaneously
   - Use "sequential" for process-driven workflows (e.g., requirements → design → implementation → QA)

5. **Team Size**: Generally 3-6 personas is ideal. Too few lacks perspective; too many becomes unwieldy.

6. **Role Coverage**: For typical product development scenarios, consider including:
   - Decision maker (Product Owner, Tech Lead)
   - User advocate (UX Designer, Customer Success)
   - Technical experts (Engineers, Architects)
   - Quality/Risk (QA, Security, DevOps if relevant)

**Important:** Return ONLY the JSON object, no additional explanation or commentary.
"##)]
pub struct PersonaTeamGenerationRequest {
    pub context: String,
    #[serde(skip_serializing_if = "String::is_empty")]
    pub role_descriptions: String,
    #[serde(skip_serializing_if = "String::is_empty")]
    pub team_graph: String,
}

impl PersonaTeamGenerationRequest {
    /// Creates a new generation request.
    pub fn new(context: String) -> Self {
        Self {
            context,
            role_descriptions: String::new(),
            team_graph: String::new(),
        }
    }

    /// Sets the role descriptions.
    pub fn with_role_descriptions(mut self, descriptions: String) -> Self {
        self.role_descriptions = descriptions;
        self
    }

    /// Sets the team graph (Mermaid diagram).
    pub fn with_team_graph(mut self, graph: String) -> Self {
        self.team_graph = graph;
        self
    }
}

impl PersonaTeam {
    /// Creates a new PersonaTeam.
    pub fn new(team_name: String, context: String) -> Self {
        Self {
            team_name,
            context,
            personas: Vec::new(),
            execution_strategy: None,
        }
    }

    /// Adds a persona to this team.
    pub fn add_persona(&mut self, persona: Persona) -> &mut Self {
        self.personas.push(persona);
        self
    }

    /// Sets the execution strategy.
    pub fn with_execution_strategy(mut self, strategy: ExecutionModel) -> Self {
        self.execution_strategy = Some(strategy);
        self
    }

    /// Loads a PersonaTeam from a JSON file.
    ///
    /// # Errors
    ///
    /// Returns an error if the file cannot be read or parsed.
    pub fn load(path: impl AsRef<std::path::Path>) -> Result<Self, std::io::Error> {
        let content = std::fs::read_to_string(path)?;
        serde_json::from_str(&content)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))
    }

    /// Saves this PersonaTeam to a JSON file.
    ///
    /// # Errors
    ///
    /// Returns an error if the file cannot be written.
    pub fn save(&self, path: impl AsRef<std::path::Path>) -> Result<(), std::io::Error> {
        let content = serde_json::to_string_pretty(self)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))?;
        std::fs::write(path, content)
    }
}

/// Formats participants information with relation interpretation.
///
/// The current agent (self) is marked as "YOU" or "ME", while other participants
/// are listed with their speaker information.
///
/// # Arguments
///
/// * `participants` - List of all participants in the dialogue
/// * `self_name` - Name of the current agent (persona)
fn format_participants_with_relation(
    participants: &[super::dialogue::ParticipantInfo],
    self_name: &str,
) -> String {
    participants
        .iter()
        .map(|p| {
            if p.name == self_name {
                format!(
                    "- **{} (YOU)** - {}: {}",
                    p.name, p.role, p.description
                )
            } else {
                format!("- **{}** - {}: {}", p.name, p.role, p.description)
            }
        })
        .collect::<Vec<_>>()
        .join("\n")
}

/// Formats messages with speaker information.
///
/// Each message is formatted as "[Speaker]: content"
fn format_messages(messages: &[(super::dialogue::Speaker, String)]) -> String {
    messages
        .iter()
        .map(|(speaker, content)| format!("[{}]: {}", speaker.name(), content))
        .collect::<Vec<_>>()
        .join("\n")
}

/// Structured prompt for PersonaAgent that combines persona information,
/// participants context, and current messages.
///
/// This structure allows PersonaAgent to build prompts in a type-safe way
/// and defer the actual text formatting until needed.
#[derive(ToPrompt, Serialize)]
#[prompt(template = r#"{{persona}}{% if participants %}

# Participants
{{participants}}
{% endif %}{% if current_messages %}

# Current Messages
{{current_messages}}
{% endif %}"#)]
struct PersonaAgentPrompt {
    persona: String,
    #[serde(skip_serializing_if = "String::is_empty")]
    participants: String,
    #[serde(skip_serializing_if = "String::is_empty")]
    current_messages: String,
}

pub struct PersonaAgent<T: Agent> {
    inner_agent: T,
    persona: Persona,
}

impl<T: Agent> PersonaAgent<T> {
    pub fn new(inner_agent: T, persona: Persona) -> Self {
        Self {
            inner_agent,
            persona,
        }
    }
}

#[async_trait]
impl<T> Agent for PersonaAgent<T>
where
    T: Agent + Send + Sync,
    T::Output: Send,
{
    type Output = T::Output;

    fn expertise(&self) -> &str {
        &self.persona.role
    }

    #[crate::tracing::instrument(
        name = "persona_agent.execute",
        skip(self, intent),
        fields(
            agent.name = %self.persona.name,
            agent.role = %self.persona.role,
            has_participants = intent.participants().is_some(),
            message_count = intent.to_messages().len(),
        )
    )]
    async fn execute(&self, intent: Payload) -> Result<Self::Output, AgentError> {
        // 1. Extract and format participants with relation interpretation
        let participants_text = if let Some(participants) = intent.participants() {
            format_participants_with_relation(participants, &self.persona.name)
        } else {
            String::new()
        };

        // 2. Extract and format messages
        let messages = intent.to_messages();
        let current_messages_text = if messages.is_empty() {
            String::new()
        } else {
            format_messages(&messages)
        };

        // 3. Build structured prompt
        let prompt_struct = PersonaAgentPrompt {
            persona: self.persona.to_prompt(),
            participants: participants_text,
            current_messages: current_messages_text,
        };

        // 4. Convert to text
        let prompt_text = prompt_struct.to_prompt();

        // 5. Create payload with Text + Messages (preserved)
        let mut final_payload = Payload::text(prompt_text);

        // Preserve messages structure
        for (speaker, content) in messages {
            final_payload = final_payload.with_message(speaker, content);
        }

        // Preserve attachments
        for content in intent.contents() {
            if let PayloadContent::Attachment(attachment) = content {
                final_payload = final_payload.with_attachment(attachment.clone());
            }
        }

        self.inner_agent.execute(final_payload).await
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::agent::{Agent, AgentError, Payload};
    use crate::attachment::Attachment;
    use async_trait::async_trait;
    use serde::de::DeserializeOwned;
    use std::sync::Arc;
    use tokio::sync::Mutex;

    #[derive(Clone)]
    struct RecordingAgent<T: Clone + Serialize + DeserializeOwned + Send + Sync + 'static> {
        calls: Arc<Mutex<Vec<Payload>>>,
        response: T,
    }

    impl<T: Clone + Serialize + DeserializeOwned + Send + Sync + 'static> RecordingAgent<T> {
        fn new(response: T) -> Self {
            Self {
                calls: Arc::new(Mutex::new(Vec::new())),
                response,
            }
        }

        async fn last_call(&self) -> Option<Payload> {
            self.calls.lock().await.last().cloned()
        }
    }

    #[async_trait]
    impl<T> Agent for RecordingAgent<T>
    where
        T: Clone + Serialize + DeserializeOwned + Send + Sync + 'static,
    {
        type Output = T;

        fn expertise(&self) -> &str {
            "Test agent"
        }

        async fn execute(&self, intent: Payload) -> Result<Self::Output, AgentError> {
            self.calls.lock().await.push(intent);
            Ok(self.response.clone())
        }
    }

    #[tokio::test]
    async fn persona_agent_preserves_attachments() {
        let persona = Persona {
            name: "Tester".to_string(),
            role: "Attachment Checker".to_string(),
            background: "Validates payload handling.".to_string(),
            communication_style: "Direct and concise.".to_string(),
        };

        let base_agent = RecordingAgent::new(String::from("ok"));
        let persona_agent = PersonaAgent::new(base_agent.clone(), persona);

        let attachment = Attachment::in_memory(vec![1, 2, 3]);
        let payload = Payload::text("Please inspect the data").with_attachment(attachment.clone());

        let _ = persona_agent.execute(payload).await.unwrap();

        let recorded_payload = base_agent.last_call().await.expect("call recorded");
        assert!(
            recorded_payload.has_attachments(),
            "attachments should be preserved"
        );
        let attachments = recorded_payload.attachments();
        assert_eq!(attachments.len(), 1);
        assert_eq!(attachments[0], &attachment);
    }

    #[tokio::test]
    async fn persona_agent_works() {
        let persona = Persona {
            name: "TestBot".to_string(),
            role: "Test Assistant".to_string(),
            background: "A helpful test bot for unit testing".to_string(),
            communication_style: "Direct and clear".to_string(),
        };

        let base_agent = RecordingAgent::new(String::from("response"));
        let persona_agent = PersonaAgent::new(base_agent.clone(), persona);

        let result = persona_agent.execute(Payload::text("Hello")).await.unwrap();
        assert_eq!(result, "response");

        let call = base_agent.last_call().await.expect("call recorded");
        let call_text = call.to_text();
        assert!(call_text.contains("Persona Profile"));
        assert!(call_text.contains("TestBot"));
        assert!(call_text.contains("Test Assistant"));
    }

    #[test]
    fn persona_team_serialization() {
        let mut team = PersonaTeam::new("Test Team".to_string(), "Testing scenario".to_string());

        team.add_persona(Persona {
            name: "Alice".to_string(),
            role: "Developer".to_string(),
            background: "Senior engineer".to_string(),
            communication_style: "Technical".to_string(),
        });

        team.add_persona(Persona {
            name: "Bob".to_string(),
            role: "Designer".to_string(),
            background: "UX specialist".to_string(),
            communication_style: "User-focused".to_string(),
        });

        // Serialize
        let json = serde_json::to_string_pretty(&team).unwrap();
        assert!(json.contains("Test Team"));
        assert!(json.contains("Alice"));
        assert!(json.contains("Bob"));

        // Deserialize
        let deserialized: PersonaTeam = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.team_name, "Test Team");
        assert_eq!(deserialized.personas.len(), 2);
        assert_eq!(deserialized.personas[0].name, "Alice");
        assert_eq!(deserialized.personas[1].name, "Bob");
    }

    #[test]
    fn persona_team_load_save() {
        use tempfile::NamedTempFile;

        let mut team = PersonaTeam::new("Dev Team".to_string(), "Software development".to_string());
        team.add_persona(Persona {
            name: "Charlie".to_string(),
            role: "Tech Lead".to_string(),
            background: "10 years experience".to_string(),
            communication_style: "Strategic".to_string(),
        });

        // Save to temp file
        let temp_file = NamedTempFile::new().unwrap();
        let path = temp_file.path();
        team.save(path).unwrap();

        // Load back
        let loaded = PersonaTeam::load(path).unwrap();
        assert_eq!(loaded.team_name, "Dev Team");
        assert_eq!(loaded.personas.len(), 1);
        assert_eq!(loaded.personas[0].name, "Charlie");
    }

    #[test]
    fn persona_team_generation_request_prompt() {
        use crate::ToPrompt;

        let request = PersonaTeamGenerationRequest::new(
            "Product development meeting for HR SaaS".to_string(),
        )
        .with_role_descriptions("PO, Designer, Engineer".to_string());

        let prompt = request.to_prompt();
        assert!(prompt.contains("Persona Team Generation Task"));
        assert!(prompt.contains("Product development meeting"));
        assert!(prompt.contains("PO, Designer, Engineer"));
    }

    #[tokio::test]
    async fn persona_agent_formats_participants_with_self_as_you() {
        use crate::agent::dialogue::ParticipantInfo;

        let persona = Persona {
            name: "Alice".to_string(),
            role: "PM".to_string(),
            background: "Product manager".to_string(),
            communication_style: "Strategic".to_string(),
        };

        let participants = vec![
            ParticipantInfo::new(
                "Alice".to_string(),
                "PM".to_string(),
                "Product manager".to_string(),
            ),
            ParticipantInfo::new(
                "Bob".to_string(),
                "Engineer".to_string(),
                "Backend developer".to_string(),
            ),
        ];

        let base_agent = RecordingAgent::new("response".to_string());
        let persona_agent = PersonaAgent::new(base_agent.clone(), persona);

        let payload = Payload::text("Task").with_participants(participants);

        let _ = persona_agent.execute(payload).await.unwrap();

        let call = base_agent.last_call().await.unwrap();
        let call_text = call.to_text();

        // Alice should be marked as "YOU"
        assert!(call_text.contains("Alice (YOU)"));
        // Bob should not be marked as "YOU"
        assert!(call_text.contains("**Bob**"));
        assert!(!call_text.contains("Bob (YOU)"));
    }

    #[tokio::test]
    async fn persona_agent_formats_messages() {
        use crate::agent::dialogue::Speaker;

        let persona = Persona {
            name: "Agent".to_string(),
            role: "Assistant".to_string(),
            background: "Helper".to_string(),
            communication_style: "Friendly".to_string(),
        };

        let base_agent = RecordingAgent::new("response".to_string());
        let persona_agent = PersonaAgent::new(base_agent.clone(), persona);

        let payload = Payload::from_messages(vec![
            (Speaker::System, "System instruction".to_string()),
            (Speaker::user("Alice", "PM"), "User message".to_string()),
        ]);

        let _ = persona_agent.execute(payload).await.unwrap();

        let call = base_agent.last_call().await.unwrap();
        let call_text = call.to_text();

        // Messages should be formatted with speaker names
        assert!(call_text.contains("[System]: System instruction"));
        assert!(call_text.contains("[Alice]: User message"));
    }

    #[tokio::test]
    async fn persona_agent_preserves_messages_structure() {
        use crate::agent::dialogue::Speaker;

        let persona = Persona {
            name: "Agent".to_string(),
            role: "Assistant".to_string(),
            background: "Helper".to_string(),
            communication_style: "Friendly".to_string(),
        };

        let base_agent = RecordingAgent::new("response".to_string());
        let persona_agent = PersonaAgent::new(base_agent.clone(), persona);

        let original_messages = vec![
            (Speaker::System, "System msg".to_string()),
            (Speaker::user("Alice", "PM"), "User msg".to_string()),
        ];

        let payload = Payload::from_messages(original_messages.clone());

        let _ = persona_agent.execute(payload).await.unwrap();

        let call = base_agent.last_call().await.unwrap();
        let received_messages = call.to_messages();

        // Messages should be preserved in the payload
        assert_eq!(received_messages.len(), original_messages.len());
        assert_eq!(received_messages[0].0, Speaker::System);
        assert_eq!(received_messages[0].1, "System msg");
        assert_eq!(received_messages[1].0, Speaker::user("Alice", "PM"));
        assert_eq!(received_messages[1].1, "User msg");
    }

    #[tokio::test]
    async fn persona_agent_full_integration() {
        use crate::agent::dialogue::{ParticipantInfo, Speaker};

        let persona = Persona {
            name: "Alice".to_string(),
            role: "PM".to_string(),
            background: "Product manager with 5 years experience".to_string(),
            communication_style: "Strategic and data-driven".to_string(),
        };

        let participants = vec![
            ParticipantInfo::new(
                "Alice".to_string(),
                "PM".to_string(),
                "Product manager".to_string(),
            ),
            ParticipantInfo::new(
                "Bob".to_string(),
                "Engineer".to_string(),
                "Backend developer".to_string(),
            ),
        ];

        let messages = vec![
            (Speaker::System, "Discuss feature priorities".to_string()),
            (
                Speaker::user("Bob", "Engineer"),
                "I suggest we focus on performance".to_string(),
            ),
        ];

        let base_agent = RecordingAgent::new("Good idea".to_string());
        let persona_agent = PersonaAgent::new(base_agent.clone(), persona);

        let payload = Payload::from_messages(messages.clone())
            .with_participants(participants);

        let result = persona_agent.execute(payload).await.unwrap();
        assert_eq!(result, "Good idea");

        let call = base_agent.last_call().await.unwrap();
        let call_text = call.to_text();

        // Debug: print actual output
        println!("=== Actual call_text ===\n{}\n=== End ===", call_text);

        // Verify all components are present
        assert!(call_text.contains("# Persona Profile"));
        assert!(call_text.contains("**Name**: Alice"));
        assert!(call_text.contains("# Participants"));
        assert!(call_text.contains("Alice (YOU)"));
        assert!(call_text.contains("**Bob**"));
        assert!(call_text.contains("# Current Messages"));
        assert!(call_text.contains("[System]: Discuss feature priorities"));
        assert!(call_text.contains("[Bob]: I suggest we focus on performance"));

        // Verify messages are preserved (Text is excluded, only Message variants)
        let received_messages = call.to_messages();
        assert_eq!(received_messages.len(), 2);
        assert_eq!(received_messages[0].0, Speaker::System);
        assert_eq!(received_messages[0].1, "Discuss feature priorities");
        assert_eq!(received_messages[1].0, Speaker::user("Bob", "Engineer"));
        assert_eq!(received_messages[1].1, "I suggest we focus on performance");
    }
}
