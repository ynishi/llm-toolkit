#### Template-Based Context Access with Jinja2


The orchestrator uses **minijinja template rendering** to make context data available to agents through intent templates.

**How It Works:**

```rust
// Step 3's intent template (generated by strategy LLM)
"Create a character profile using:
- Concept: {{ step_1_output.concept }}
- Design: {{ step_2_output.emblem }}
- World: {{ user_request.world_seed.aesthetics }}"
```

When executing Step 3, the orchestrator:

1. **Passes full context to minijinja**: All `step_N_output`, `user_request`, and other context data
2. **Minijinja resolves placeholders**: Only referenced fields are extracted and rendered
3. **Agent receives rendered intent**: Clean, readable text with all placeholders expanded

**Available Context Keys:**

The orchestrator maintains these keys in context:

- `step_{step_id}_output` - JSON output from each step (e.g., `step_1_output`, `step_2_output`)
  - **Automatic key**: Always created with `step_` prefix + step_id + `_output` suffix
  - Example: If `step_id` is `"step_1"`, the key becomes `"step_step_1_output"`
- `{output_key}` - Custom alias for step output (if `output_key` is specified in strategy)
  - **User-defined key**: Set via the `output_key` field in StrategyStep
  - Example: `"output_key": "world_concept"` creates key `"world_concept"`
  - Preferred for better readability (e.g., `{{ world_concept.theme }}` instead of `{{ step_step_1_output.theme }}`)
- `step_{step_id}_output_prompt` - ToPrompt version (human-readable string)
- `{output_key}_prompt` - ToPrompt version with custom alias (if `output_key` is specified)
- `previous_output` - Convenience reference to the immediately previous step's output
- `user_request` - External input data added via `context_mut().insert()`
- Custom keys - Any data added before execution

**Dot Notation for Nested Access:**

```rust
// Access nested JSON fields
{{ step_1_output.concept }}                     // Simple field
{{ step_2_output.data.items }}                  // Nested object
{{ user_request.world_seed.aesthetics }}        // Deep nesting
{{ step_3_output.results[0].name }}             // Array indexing (if supported)
```

**Benefits:**

- **Simple & Standard**: Uses standard Jinja2 templating, familiar to many developers
- **No Semantic Matching**: Direct key resolution—no LLM calls for placeholder mapping
- **Full Information**: Complete step outputs available, minijinja extracts what's needed
- **Type Safety**: Dot notation errors are caught at template render time
- **Automatic**: Strategy generation LLM creates appropriate placeholder references

**Common Pitfall:**

❌ **Manually extracting intermediate results**:
```rust
// DON'T DO THIS - Orchestrator handles it automatically!
let result = orchestrator.execute(task).await;
let concept = extract_from_context("step_1_output")?; // Not accessible!
let emblem = extract_from_context("step_2_output")?;  // Not accessible!
```

✅ **Correct approach - Design the final agent to aggregate**:
```rust
// The LAST agent's intent template should request all needed data
"Generate final output including:
- Concept: {{ concept_content }}
- Emblem: {{ emblem_design }}
- Profile: {{ character_profile }}"

// Then final_output contains everything
let result = orchestrator.execute(task).await;
let complete_data = result.final_output; // All data aggregated by final agent
```

**Understanding Context Keys and Placeholder Resolution:**

Intent templates reference context data using Jinja2-style placeholders. The orchestrator stores all data in a context HashMap and passes it to minijinja for template rendering.

**How Context Keys Work:**

1. **Step outputs are automatically stored**:
   - `step_{step_id}_output` - JSON version (e.g., `step_1_output`, `step_world_concept_generation_output`)
     - **Note**: The `step_` prefix is **automatically added**. If your `step_id` is `"step_1"`, the key becomes `"step_step_1_output"`.
   - `{output_key}` - Custom alias (e.g., `world_concept` if `output_key: "world_concept"` is specified)
   - `step_{step_id}_output_prompt` - ToPrompt version (if available)
   - `{output_key}_prompt` - ToPrompt version with custom alias (if available)
   - `previous_output` - Updated after each step to reference the most recent output

2. **Placeholder resolution is direct**:
   - `{{ step_1_output }}` → Looks up `step_1_output` key in context
   - `{{ world_concept.theme }}` → Looks up `world_concept` (custom output_key) then accesses `.theme` field
   - `{{ step_1_output.concept }}` → Looks up `step_1_output` then accesses `.concept` field
   - `{{ user_request.world_seed.aesthetics }}` → Looks up `user_request` then navigates nested fields
   - No semantic matching or alias resolution—just direct key lookup

3. **Accessing nested fields with dot notation**:
   - Intent templates support Jinja2-style dot notation
   - Example: `{{ step_3_output.user.profile.role }}` accesses nested JSON fields
   - Works for any depth of nesting in JSON objects

**Adding External Context:**

You can add custom context before execution using `context_mut()`:

```rust
orchestrator.context_mut().insert(
    "user_request".to_string(),
    serde_json::json!({"name": "Alice", "world_seed": {"aesthetics": "Gothic"}})
);
```

This data is **immediately available** in intent templates:

```rust
// Intent template can directly reference it
"Create a profile for {{ user_request.name }} with {{ user_request.world_seed.aesthetics }} aesthetics"
```

**Best Practice:**

Use direct, explicit placeholder references in intent templates:

```rust
// ✅ Recommended: Direct step references with dot notation
// Intent: "Process {{ step_1_output.concept }} and {{ step_2_output.design.colors }}"

// ✅ Also good: External context references
// Intent: "Use world seed: {{ user_request.world_seed.aesthetics }}"

// ✅ Convenience: previous_output for simple sequential workflows
// Intent: "Refine {{ previous_output }}"
```

**Why?** The orchestrator's `context` was internal. But now you can access it!

